csc.rsp holds preprocessor directives

eventually, I'll want to switch to an event-based architecture for everything just like I did for combat. 
this way, I don't need to check for conditions at every single point in code, but can simply state that something 
is happening and let the rest of the code modify the outcome (e.g. add movement for longstrider when 
movement is ordered instead of checking a condition)

anything that needs to be saved for a creature should be stored on the Traveller/NPC/PlayerCharacter, 
not on the Instantiated version.

if something needs to be shared among creatures, there's a good chance it should be an SO
- this is because it only needs to be created once (e.g. if pack tactics might get reused)

color palette - base blue #3993DD, solid base blue #4D86B4, dark blue #002B66, yellow #DF9F1F, almost white #E6F4F1

there's a bug where if the level's loading and blocks are made transparent (e.g. the player moves),
those blocks will become empty voxels.
- possibly, the same issue happens when saving and voxels are currently transparent. 
- maybe need to disable the feature before saving?

can use this code in voxel play to ensure voxels are always loaded:
	VoxelPlayEnvironment.Textures
	// Add any other voxel found inside Defaults
	LogMessage("Loading all voxels in VoxelPlay/Defaults");
	VoxelDefinition[] vdd = Resources.LoadAll<VoxelDefinition>("VoxelPlay/Defaults");
	for (int k = 0; k < vdd.Length; k++) {
		AddVoxelTextures(vdd[k]);
	}

recursive loops in json serialization seem to end in null values

for json serialization: "JsonSerializationException: Unable to find a constructor to use for 
	type Orders.OrderGroup. A class should either have a default constructor, 
	one constructor with arguments or a constructor marked with the JsonConstructor attribute"

need to use TextureRotation if you want to save the rotation of a voxel (including prefabs)

need to use .Equals instead of == when comparing objects with overridden equality operation

save location - C:\Users\keanf\AppData\LocalLow\DefaultCompany
perma save location - C:\Users\keanf\Desktop\projects\unity\temp\Simpler 3D Tilemap\Assets\SavedGames\CleanStartSave

if you want a coroutine with a return value, you need to use CoroutineWithData

Managers are responsible for the life cycle of things. 
They do spawning/destroying, initialize the game, and communication between very 
different systems.
Controllers are responsible for the behavior of individual things while they're alive. 
They do movement, ai, physics, etc. They respond to signals about what's going on from 
their manager, and send signals back up to their manager so other systems can respond to 
what they're doing.

vpEnvironment.DisposeAll(); to stop vpenvironment after starting

there are two layers to objects, the actual instantiated objects/creatures (monobehaviors) and the 
information about them that's immutable, or predates their existence.

enums should be used when a list of things never changes, as in, it wouldn't change at runtime

when using the "voxel dirt additional" feature, make sure to not set Max/Min Altitude to zero, or it will not generate the layer correctly.
- also, min altitude can equal bedrock.

I tried adding another scene with a different environment/world definition. For some reason, the world will not render and 
it seems to load twice. I think for now I may give up on the idea of having multiple environments. The only thing I think it would 
provide would be quicker load times, and I'm too early on in this project to worry about saving a few seconds between environments.
It has also created a ton of headaches as I have lost functionality that Voxel Play is supposed to provide, like the first-person character controller.

sometimes when switching scenes my vp-needed objects under scenebuilder do not get disabled and both are displayed. Need to be careful about this.

need to be careful not to modify one Environment while another is active. this will trigger rendering logic that currently 
combines things from both environments, unfortunately.

did not figure out the problem with the greedy mesher, but found a workaround using a different renderer
- nope, when I try destroying a voxel in one scene, suddenly the stuff rendered in that scene is shared with the other scene somehow. 
Still need to figure this out
- for some reason, if I modify the contents of one environment while the other is rendering, it merges the two.
- I turned on compute buffers. for some reason, this seems to have helped with the rendering issue. also, another issue - sometimes when 
switching scenes my vp-needed objects under scenebuilder do not get disabled and both are displayed. Need to be careful about this.

I couldn't figure out what was causing the error that would occur when two environments ran simultaneously (threading, maybe?).
My temporary fix for this is to disable the script for the old environment when switching to a new one, and only enable the 
new one once the old one is done. However, that's not great because I won't get the speed benefit of having a loaded Environment
ready to go.

in order to fix ugly visibility issues with VP camera inside the terrain, can maybe use collision detection with 
the camera (and an invisible object between the camera and the player) to activate custom logic that makes voxels 
visible (even if they are normally not rendered) and changes their opacity.
- https://kronnect.freshdesk.com/support/solutions/articles/42000058885-see-through-occluding-voxels

unfortunately, objects in different scenes are still visible to any camera in any scene. if I want multiple Environments loaded
without overlapping, I need to somehow hide one of them.

there are several objects that voxel play expected only one to exist, including the environment (singleton), 
the chunk manager, the FX particle manager, and the voxel play world object.

in order to take advantage of scenes fully, I need objects that should be in the scene to not be created dynamically.
This is because objects created at runtime are added to the active scene, so I'd either need to wait until the scene 
is set to active before creating them (which may cause a load time or pop-in), or have them be a part of the scene ahead of time.

issues - I want to have a vp environment per-scene so I can load one while the other's being played, but 
I have to make the environment non-singleton to do that, and even then, objects created in one of the scenes are
placed in the active scene.

Can use VoxelPlay events defined in environment to efficiently/clearly wait for things to finish

the player exists on the square above the slope

issue - the character controller is integral to the way the first-person movement works, but it causes collisions in the other mode
- can remedy this by destroying the controller and recreating it, then refreshing with checkcharactercontroller
- can also change the class to not be so dependent on the character controller
- I think in the long-term, due to the need for 3 basic modes (1st person, 3rd person, and disembodied/edit mode) and voxel play's 
	lack of controller support, I will need my own 1st person camera with many of voxel play's features. but I don't want to get bogged
	down in that yet.

can add custom behavior to voxels by attaching a script that inherits from VoxelPlayInteractiveObject

consider using Rider from jetbrains, money permitting

can use ScriptableObject to create instances of a class in text form, which can be easily modified (HP, prefab, faction, etc)
can use CreateAssetMenu to create an instance of a scriptableobject quickly

can use singletons and donotdestroyonload to prevent key assets from getting destroyed on scene changes, like audio for example.

can use Action/Func to create events
- Events are useful when you need to decouple things, for example you can just emit a "wave" event and you don't need to 
specify what happens afterward specifically, other code can hook into the event without the "wave" logic needing to be changed.

delegates are just variables that hold methods.

could create objects that need to persist between scenes under a "dontdestroyonload" object

can use WaitWhile in a coroutine to listen for an event before continuing

try using getawaiter.getresult on tasks (they're like promises) in a non async function if you want to block on the result

can use FileManager.writetofile/loadfromfile to persist data to disk. can use jsonutility to serialize entire classes, like a 
class that holds all saveable information about the game

can store permanent files here - Path.Combine(Application.persistentDataPath, <file name>); File.WriteAllText(<path>, <string>);
File.readalltext()

can use JSON.Net if I have issues with jsonutility not serializing the types I want

vp environments are singletons by default. if I want to be able to switch between scenes quickly (without loading a vp environment)
I'll need to modify the source.

use CaveDefaultGenerator and other generators to create interesting details.

